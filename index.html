<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Infinite Pickaxe Miner</title>
<style>
body { margin: 0; overflow: hidden; }
canvas { display: block; margin: 0 auto; }
</style>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
<script>
const config = {
    type: Phaser.AUTO,
    width: 400,
    height: 600,
    backgroundColor: '#87CEEB',
    physics: { default: 'arcade', arcade: { gravity: { y: 0 } } },
    scene: { preload: preload, create: create, update: update }
};

const game = new Phaser.Game(config);

let blocks;
let pickaxe;
let blockSize = 50;
let speed = 0.5; // slow downward movement
let bounceVelocity = 0; // velocity for bounce effect
const bounceStrength = 5; // how strong the bounce is

const oreTypes = [
    { name: 'stone', color: 0x808080 },
    { name: 'iron', color: 0xD8BFD8 },
    { name: 'gold', color: 0xFFD700 },
    { name: 'diamond', color: 0x00FFFF },
    { name: 'netherite', color: 0x2F4F4F }
];

function preload() {}

function create() {
    blocks = this.add.group();

    for (let i = 0; i < 20; i++) {
        addBlock(this, i);
    }

    pickaxe = this.add.rectangle(200, 100, 40, 40, 0xFF0000);
    this.physics.add.existing(pickaxe);

    this.cameras.main.startFollow(pickaxe, true, 0.1, 0.1);
}

function addBlock(scene, index) {
    const ore = Phaser.Math.RND.pick(oreTypes);
    const x = 200;
    const y = pickaxe.y + 600 - index * blockSize;
    const block = scene.add.rectangle(x, y, blockSize, blockSize, ore.color);
    block.oreType = ore.name;
    blocks.add(block);
}

function update() {
    // Apply bounce velocity
    pickaxe.y += speed + bounceVelocity;

    // Slowly reduce bounce velocity (gravity effect)
    if (bounceVelocity > 0) bounceVelocity -= 0.3; // adjust for smooth fall
    if (bounceVelocity < 0) bounceVelocity = 0;

    blocks.getChildren().forEach(block => {
        // move blocks relative to pickaxe
        block.y -= speed;

        if (block.y < pickaxe.y - 650) {
            block.destroy();
            addBlock(this, 0);
        }

        // Collision: auto mine
        if (Phaser.Geom.Intersects.RectangleToRectangle(pickaxe.getBounds(), block.getBounds())) {
            block.destroy();
            bounceVelocity = bounceStrength; // pickaxe jumps up slightly
        }
    });
}

// TNT / Nuke
function triggerTNT() {
    blocks.getChildren().forEach(block => {
        if (block.y > pickaxe.y && block.y < pickaxe.y + 250) block.destroy();
    });
}

function triggerNuke() {
    blocks.getChildren().forEach(block => block.destroy());
}
</script>
</body>
</html>
